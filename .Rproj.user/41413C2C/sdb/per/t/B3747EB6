{
    "contents" : "# Operators\n2 == 2\nexp(1/4)\ninstall.packages('gapminder')\nlibrary(gapminder)\nhead(gapminder)\ntail(gapminder)\n\nstr(gapminder)\nlife <- gapminder$lifeExp\nlength(life)\ngapminder[100, ]\ninstall.packages('ggplot2')\ninstall.packages('lazyeval')\ninstall.packages('dplyr')\ninstall.packages('tidyr')\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nggplot(data = gapminder, aes(x=year, y=lifeExp, color = continent)) + geom_point()\n# set variable for global aesthetic defaults...\np <- ggplot(data = gapminder, aes(x=year, y=lifeExp, by=country, color = continent))\n# ... then add layers\np + geom_point()\n# can strip color out of global aesthetics and restrict only to one line\np <- ggplot(data = gapminder, aes(x=year, y=lifeExp, by=country))\np + geom_point() + geom_line(aes(color = continent))\n# to see points on top of line, put them as last layer\np + geom_line(aes(color = continent)) + geom_point()\n# SCALE\np <- ggplot(data = gapminder, aes(x=year, y=lifeExp, by=country, color = log(gdpPercap)))\np + geom_point()\n# dev.new opens new graphics window\ndev.new()\ndev.cur()\ndev.list()\nstr(gapminder)\n# type on cheat sheet... 'hight' should be 'high', and change m.p. to fit data\np + geom_point() + scale_color_gradient2(\n  low = \"red\", high = \"blue\", mid = \"white\", midpoint = 8)\n# here (10) is the number of colors\np + geom_point() + scale_color_gradientn(colours = topo.colors(10))\n# Facets - allow putting multiple panels on plot\n# facet all the data by continent\np + geom_point() + facet_wrap(~ continent)\n# 2 tricks for visualizing data when have lots of points on top of each other\n# jitter - offsets points\np + geom_jitter()\n# alpha - sets transparency of points\np + geom_point(alpha = 0.3)\n# Can label things, year or country\np + geom_point() + geom_text(aes(label = year))\n# Include subsets directly in plot\n# ggplot(data = subset(blah blah), ...)\n# args() gives argument info about function\n# filter replaces which\n# filter by rows\nfilter(gapminder, country == 'Canada')\n# filter by cols with select, instead of gapminder[, 'country']\nselect(gapminder, country)\n# doesn't work bc no column w/ name Canada\nselect(gapminder, Canada)\nselect(gapminder, starts_with('C'))\n#\n# pipe %>%\ngroup_by(gapminder, continent) %>%\n  summarise(mean_life = mean(lifeExp))\nhead(mutate(gapminder, gdp = gdpPercap * pop))\nhead(transmutate(gapminder, gdp = gdpPercap * pop))\nhead(arrange(gapminder, contient) %>%\n       mean(., lifeExp))\ngapminder <- tbl_df(gapminder)\n# 1. For each continent, what country had the smallest population in 1952, 1972, and 2002?\nfilter(gapminder, year == 1952 | year == 1972 | year == 2002)\n# or\n# don't do this, will recycle every single one:\n# filter(gapminder, year == c(1952, 1972, 2002)) %>%\n#    arrange(desc(year))\n# this is equivalent of the first one\nfilter(gapminder, year %in% c(1952, 1972, 2002))\ngapminder %>%\n  filter(year %in% c(1952, 1972, 2002)) %>%\n  group_by(continent, year) %>%\n  slice(which.min(pop)\n  %>% View(.))\n# or\n# x <- gapminder %>%\n# filter(year %in% c(1952, 1972, 2002)) %>%\n#   group_by(continent, year) %>%\n#   summarise(index = which.min(pop))\n# filter(gapminder, year %in% c(1952, 1972, 2002)) %>%\n#      group_by(continent, year) %>%\n#      count(continent)\n# 2. create a graph of the total population of each continent over time\n#\n# 3. calculate the mean gdpPercap for each country\n#\n# 4. calculate the mean gdp for each country\n\n## Thurs. 10/15/15\n\nmeow <- c(1,2,3,4,10,11,12)\nmeow[c(5, length(meow))]\n# create a double vector (numeric)\ndbl_vec <- c(1.2,1.3,1.4,2.5)\nstr(dbl_vec)\ntypeof(dbl_vec)\n# create an integer vector (numeric, but discrete)\nint_vec <- c(1,2,3,4) # this just produces a double vector\ntypeof(int_vec)\n# Logical vector\nlog_vec <- c(TRUE, FALSE, TRUE)\ntypeof(log_vec)\nlog_vec\nsum(log_vec)\n# character vector\nchr_vec <- c('a', 'b', 'c')\nchr_vec\ntypeof(chr_vec)\n\n# coercion - converting\n\nz <- read.csv(text = 'value\\n12\\n1\\n.\\n9') # equivalent of 12 1.9\nstr(z)\ntypeof(z[[1]])\n# can't go first as double, that will just give you label names (factors)\nas.double(z[[1]]) # 3 2 1 4 are factor levels\n# need t\nas.character(z[[1]])\nas.double(as.character(z[[1]])) # . is NA\n\n## To avoid this, when read a file setting stringsAsFactors = FALSE means that no character columns will be put into R as factors\nz <- read.csv(text = 'value\\n12\\n1\\n.\\n9',\n    stringsAsFactors = FALSE)\n\n# 2 dimensional structures\n\n# Matrix\na <- matrix(1:6, ncol=3, nrow=2,)\na\na[,3]\nlength(a)\ndim(a)\nnrow(a)\nncol(a)\nx <- (c('a', 'b', 'c', 'd', 'e', 'f'))\na <- matrix(x, ncol = 3, nrow =2)\na\nx <- c(x, 1,2,3)\nx\n\n# Data frames\nstr(gapminder)\n\n# Always be thinking about what object am I working with, and what object am I sending to my function\n\n############################################\n\n# aes in 'global' settings\nggplot(data = gapminder, aes(x = year, y = lifeExp)) +\n  geom_point()\n\n# aes specific to a geom (in this case geom_point)\nggplot(data = gapminder, aes(x = year, y = lifeExp)) +\n  geom_point()\n\n# coloring by data\n# aes in 'global' settings - coloring in continent\nggplot(data = gapminder, aes(x = year, y = lifeExp, color = continent)) +\n  geom_point()\n\n# aes specific to a geom (in this case geom_point)\nggplot(data = gapminder) +\n  geom_point(aes(x = year, y = lifeExp, colour = continent))",
    "created" : 1445950689666.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4131069309",
    "id" : "B3747EB6",
    "lastKnownWriteTime" : 1445193963,
    "path" : "~/R_projects copy/Intro-to-R/Intro_R.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}