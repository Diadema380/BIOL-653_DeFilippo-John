{
    "contents" : "library(ggplot2)\nlibrary(dplyr)\nlibrary(gapminder)\n# the first and second arguments are the x & y coordinates, then the data frame\nqplot(displ, hwy, data = mpg)\n# add color aesthetic, map it to drive variable\nqplot(displ, hwy, data = mpg, color = drv)\n# Can add statistic, some summary of the data, e.g. a smoother (technically called loess) by adding geom argument that includes the points, so can see the data, and the smooth geom. 95th percent confidence interval is indicated by the gray zone.\nqplot(displ, hwy, data = mpg, geom = c(\"point\", \"smooth\"))\n# For one dimensional data, only specifying a single variable plots a histogram. Instead of color argument, specify the fill argument for what type of drive it is.\nqplot(hwy, data = mpg, fill = drv)\n# Facets are like panels in Lattice. Instead of color-coding different groups can have separate panel plots for subsets of the data indicated by a factor variable.\n# Format for facets variable is # panel columns variable on right hand side, and # rows of matrix variable on left hand side, separated by tilde. # If only one column or row, use a period.\n# Three dot plots on one row\nqplot(displ,  hwy,  data = mpg, facets = .~ drv)\n# Three histograms in one column\nqplot(hwy, data = mpg, facets = drv ~ ., binwidth = 2)\n# To plot on a log scale:\nqplot(log(eno), data = maacs, fill = mopos)\n# To do a density smooth, add geom 'density':\nqplot(log(eno), data  =  maacs, geom = \"density\")\n# To split out the mouse pos./neg. peaks into colors \nqplot(log(eno), data = maacs, geom =  \"density\", color = mopos)\n# for a simple 2D scatter plot of log(eno) vs. log(pm25)\nqplot(log(pm25), log(eno), data = maacs)\n# To separate out the allergic and non-allergic groups by the data point shape argument\nqplot(log(pm25), log(eno), data  =  maacs, shape = mopos)\n# To separate out the two groups by color:\nqplot(log(pm25), log(eno), data = maacs, color = mopos)\n# To smooth the linear relationship between the two groups using standard linear regression model instead of loess, use lm:\nqplot(log(pm25), log(eno), data = maacs, color = mopos, geom = c(\"point\", \"smooth\"), method = \"lm\")\n# Instead of overlapping and color coding the data, can split it out into two plots using facets argument. Will get two columns by specifying the mouse pos. variable:\nqplot(log(pm25), log(eno), data = maacs, color = mopos, geom = c(\"point\", \"smooth\"), method = \"lm\", facets = .~  mopos)\n\n############# 9/29/15\n#1\ngapminder %>% \n  group_by(country) %>%\n summarize(mean_gdpPercap = mean(gdpPercap))\n#2 What countries have the best and worst life expectancies in each continent?\nby country\nget gdp\nmean gdp\n\ngapminder %>% \n  group_by(country) %>%\n  mutate(gdp = pop *cgdpPercap)\n\n#3 Create a graph of the total population of eah continent over time\ntotal_pop_df <-\ngapminder %>% \n  group_by(country, year) %>%\n  summarize(total_pop = sum(pop))\n\nggplot(data = total_pop_df, aes(x = year, y = total_pop, colour = continent)) +\n  geom_point()\n\nby country\nby year\ntotal pop\n\n#4. For each coninent, what country had the smallest population in 1952, 1972, and 2002? (google for help if you need to!)\n#pseudo code\n# by continent\n# subset 1952, 1972, 2002\n# minimum population\n\nif have list of items you want to compare things against, use %in%\n# year, are you 1952? year, are you 1972? year, are you 2002?\n  \n  gapminder <- tbl_df(gapminder)\ngapminder %>%\n  # gapminder %>%\n  # filter(year == 2002) %>%\n  # group_by(continent) %>%\n  # mean(., pop)\n  #\n  # equivalent of\n  #\n  # mean(group_by((filter(gapminder, year == 2002)), continent)$pop)\n  #\n  filter(year %in% c(1952, 1972, 2002)) %>%\n  group_by(continent, year) %>%\n  # have things grouped, and for each group want min. value for each grouping. Want the whole row of data that has the min. value. Slice cuts up your data by row.\n# which gets you an index, position in an object that something exists. which.min = what is the position of the minimum value? \n  slice(which.min(pop)) %>%\n# This will slice whole row of data. To select column\nselect(country, year, pop)\n\n# Extra questions\n#1 How many countries are there on each continent?\n\ngapminder %>%\n  group_by(continent) %>%\n  slice(which.min(pop)) %>%\n  \n#2 What countries have the best and worst life expectancies in each continent? (for each year)\n\n# Challenge\n# 3. Which country experienced the sharpest 5-year drop in life expectancy?\n# hint: lead() and lag() functions\n\n  \n##########################\n\nlibrary(gapminder)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# 1. Use points and colors to identify continents\n\nggplot(data = gapminder, aes(x = continent, fill = continent)) +\n  geom_histogram()\n\n# 2. The per capita gdp has a very large range; use a transformation to linearize the data\n\nstr(gapminder)\n#lgdp <- log10(gapminder[6])\n#ggplot(data = gapminder, aes(x = lgdp, y=lifeExp, colour = continent)) +\n  geom_point()\n# Don't know how to automatically pick scale for object of type data.frame. Defaulting to continuous\n# Error: geom_point requires the following missing aesthetics: x\n\nggplot(data = gapminder, aes(x = log10(gdpPercap), y=lifeExp, colour = continent)) +\n  geom_point()\n\n# 3. Include a simple linear fit to the transformed data\n\nggplot(data = gapminder, aes(x = log10(gdpPercap), y=lifeExp, colour = continent)) +\n  geom_point() +\n  geom_smooth(method = lm, se = FALSE)\n\n# 4. Plot the density functions of life expectancy for each continent\n\nggplot(data = gapminder, aes(x = lifeExp, fill = continent)) +\n  geom_density() +\n  facet_wrap( ~ year, ncol = 4)\n\n# 5. Fix the bottom continent labels\n\nggplot(data = gapminder, aes(x = continent, y = lifeExp)) +\n  geom_boxplot() +\n  facet_wrap( ~ year, ncol = 4) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n# 6. \n\nggplot(data = gapminder, aes(x = lifeExp, fill = continent)) +\n  geom_density()\n\n# 7. Plot the mean life expectancy on a density plot for Asia\n\nggplot(data = gapminder, aes(x = lifeExp, fill = (continent[3]))) +\n  geom_density() +\n  geom_vline(aes(xintercept = mean(lifeExp)))\n             \n             \n# 8a. Create a data frame of the mean life expectancies for each continent\n\nmean_df <-\ngapminder %>% \n  group_by(continent) %>%\n  summarize(mean_lifeExp = mean(lifeExp))\n  \n# 8b. Plot the density plot of life expectancies for each continent and draw a vertical line to mark the mean life expectancy for each continent.\n\ndensity\nfacets for continent\nmean life exp lines\n\nggplot(data = gapminder, aes(x = lifeExp, fill = continent)) + #add data layer\n  geom_density(alpha = 0.5) +\n  # want geom_vline to act on something other than the default data set\n  geom_vline(data = mean_df, aes(xintercept = mean_lifeExp)) +\n  facet_wrap( ~ continent) #facet wrap by continent (do last)\n\n\n# Find the mistakes\n\nhw_gapminder <- read.csv('./R_projects/hw_gapminder.csv')\n\nmean_lifeExp <- mean(hw_gapminder$lifeExpe) #Typo... should be lifeExp\nmean_lifeExp <- mean(hw_gapminder$lifeExp)\n\n# need 2nd concatenate\nsmall_set <- hw_gapminder[c(1, 2, 3, 4, 1300:1304), ('country', 'continent', 'year')]\nsmall_set <- hw_gapminder[c(1, 2, 3, 4, 1300:1304), c('country', 'continent', 'year')]\n\nmean_gdp <- mean(hw_gapminder$gdpPercap)\nsummary(hw_gapminder$gdpPercap)\n# has 5 NAs that need to be removed\nmean_gdp <- mean(hw_gapminder$gdpPercap, na.rm=TRUE)\n\n\n# need == for equivalence\nmax_country <- hw_gapminder$country[which(hw_gapminder$lifeExp = max(hw_gapminder$lifeExp))]\n# I get Japan, but also 142 levels\nmax_country <- hw_gapminder$country[which(hw_gapminder$lifeExp == max(hw_gapminder$lifeExp))]\n\n\nThe desired outcomes are:\n  \n  mean_lifeExp\n\n## [1] 59.47444\n\nsmall_set\n\n##                    country continent year\n## 1              Afghanistan      Asia 1952\n## 2              Afghanistan      Asia 1957\n## 3              Afghanistan      Asia 1962\n## 4              Afghanistan      Asia 1967\n## 1300 Sao Tome and Principe    Africa 1967\n## 1301 Sao Tome and Principe    Africa 1972\n## 1302 Sao Tome and Principe    Africa 1977\n## 1303 Sao Tome and Principe    Africa 1982\n## 1304 Sao Tome and Principe    Africa 1987\n\nmean_gdp\n\n## [1] 7210.019\n\nmax_country\n\n## [1] \"Japan\"\n\nq()\n\n############\n## 10/6/15\nhw_gapminder <- read.csv('./R_projects/hw_gapminder.csv')\ngm <- gapminder\n\n# Select rows 10 to 20 of the country and life expectancies in gapminder\n\nrows 10:20\ncols counry, lifeExp\n\n#gm(c('country', 'lifeExp'),[10:20,])) doesn't work\ngm[10:20, c('country', 'lifeExp')]\n\n# Select rows 1 to 10, 20, and 100\ngm[c(1:10, 20, 100), ]\n\n# What are the 3 subsetting operators?\n# object[] = multiple values\n# object$ = named values\n# object[[]] = lists(mostly)\n\n# PEPPER PACKETS = sbsetting nested objects\n\n# have to build inside out\n\nshaker\npepper packet (pp)\ngrains (g)\n\npp1 <- c('g1', 'g2', 'g3')\npp2 <- pp1\npp3 <- pp1\n\n# put pepper packets in shaker, using a list\npp2\n\nshaker <- list(pp1, pp2, pp3) # list shaker has 3 objects\nshaker\n\n# get vector pepper packet 1; get the 1st element in the list shaker 1\nshaker[[1]]\n\n# get the 3rd grain out of pepper packet 1\nshaker[[1]][3] #vector w/in a list, so single bracket\n\nis.list(shaker)\ntypeof(shaker) #type of object stored in that list, a vector\n\nshaker[1]\nshaker[[1]]\nshaker[1][2] # there is no 2\nshaker[3]\n\n# [] simplifies (preserves the type of the origial object, just makes it a smaller piece of it) your object by taking it the smallest one\n\n##############################\n# 10/13/15\n#\n# find country and year with largest decrease in life expectancy\ngapminder %>%\n  group_by('country') %>%\n  # can't trust that it's already arranged by year, so do yourself\n  arrange(year) %>%\n  # mutate will create a new column, diff\n  mutate(diff = lifeExp - lead(lifeExp)) %>% # lag says look at previous row's value, lead says next ??\n# Now want to know this for each continent\n  # group new data by continent to look within each continent to look for outliers (smallest one)\ngroup_by('continent') %>%\n# to look at just one row, use slice to slice out select rows to find the smallest or largest decrease in life expectancy\n  slice(which.min(diff))\n# give slice a condition and it subsets out only those rows we want, smallest value with greatest negative\n# (works like filter)\n\n## Write out in a paragraph all the things you want to do: hey data, I want you to do this, then do this...\n## Put comment in front of every sentence, and write line of code that corresponds to that sentence\n\n########\n# For Loops\n#\n\nc(7, 10, 11, 52, 55, 83, 101, 9)\n# reference ith number of vector\n# foo[1] is 7, foo[4] is 52\n\n\n##############\n# 10/15/15\n#\nanimals <- c('cats', 'dog', 'ponies', 'koi', 'chicken', 'moose')\nfor (i in animals) {\n  len <- nchar (i)\n  print(len)\n}\n\nfor (i in 1:length(animals)) {\n  len <- nchar(animals[i])\n  print(len)\n}\n\nsquare <- vector(length = 10)\nseries <- 1:10\nfor (i in series) {\n square <- i^2\n print(square)\n}\n\nseries <- 1:10\nadd_them <- 0\nfor (i in series) {\n  browser()\n  add_them <- i + add_them\n  print(add_them)\n}\n\n\n#######################\n# Tue 10/20/2015\n#\n# Podcasts - \n# 'Not so standard deviations'\n# 'R Talk'\n#\n\n# 1) Print each value of this matrix.\n\nmat <- matrix(1:100, nrow = 10, ncol = 10)\nfor (i in 1:length (mat)) {\n  print(i)\n}\n\n# 2) Multiply each value in this matrix by 7 and store it in a 10 x 10 matrix\n\nmat <- matrix(1:100, nrow = 10, ncol = 10)\nnat <- matrix(NA, nrow = 10, ncol = 10)\nfor (i in 1:length(mat)){\n  nat[i] <- mat[i]*7\n}\nnat\n\n# 3a) Print these values as part of a string that looks something like 'n = 16'.\n\n#Try to describe in words how I creating the vector of numbers that you are going to use.\n\nset.seed(1)\nx <- round(runif(min = 10, max = 100, n = 15))\nfor (i in 1:length(x)){\n  print(paste('n =', x[i]))\n}\n\n# 3b) Now modify this loop to store these strings in a new vector called counts.\n\nset.seed(1)\nx <- round(runif(min = 10, max = 100, n = 15))\nfor (i in 1:length(x)){\n  counts <- (paste('n =', x[i]))\n  print(counts)\n}\n\n# 4) Make a vector for which each entry is 2 raised to the power of it’s index (ex: the 3rd item in the vector is equal to 2^3).\n#For example your loop should return a vector that looks something like this:\n#  2, 4, 8, 16, 64, …, 1024\n\nfor (i in 1:10) {\n  two_power <- 2 ^ i\n  print(two_power)\n}\n\n# 5) Make a matrix where each entry, using indexes i for row and j for column, is equivalent to i*j. Your final output should look like:\n\nm <- matrix(NA, 12, 12)\nfor (n in 1:length(m)) {\n  i <- slice.index(m,1)\n  j <- slice.index(m,2)\n  m[n] <- i[n]*j[n]\n}\nm\n\n# 6) Make a vector where each entry is TRUE or FALSE, based on whether it’s index is even or odd.\n\nx <- 1:10\ny <- vector()\ny <- x %% 2 == 0\ny\n\n# 7) Run this code to set yourself up for question 7.\n\ntaxa <- c('Coral', 'fish', 'Fish', 'Phytoplankton', 'coral', 'phytoplankton', \n          'zooplankton', 'Zooplankton', 'Echinoderms', 'echinoderms', \n          'Cephalopods', 'cephalopods')\n\ntaxa_values <- sample(taxa, size = 100, replace=TRUE)\nset.seed(1)\ncounts <- round(runif(min = 10, max = 500, n = 100))\n\ntaxa_counts <- data.frame(taxa = taxa_values, abundance = counts)\n\n# Convert duplicate upper and lower case to all upper\ntaxa_caps <- toupper(taxa_values)\ntaxacap_counts <- data.frame(taxa = taxa_caps, abundance = counts)\n\n# 7a) Using dplyr, calculate the mean abundance of each taxonomic group, what do you notice about the output? Is it what you would expect?\n\naggregate(taxacap_counts['abundance'], by = taxacap_counts['taxa'], mean)\n\n# OK, figured out dplyr way\ngroup_by(taxacap_counts, taxa) %>%\n  summarize(mean = mean(abundance))\n\n# 7b) Hopefully not. What’s going on? Can you fix it?\n\n# I dunno, was it the upper/lower case duplicates?\n\n###################\n# Thurs 10/22/15\n#\n\n# Functions\n#\n# verbname <- function((inputarg))\nx <- 2:200\nmax(x) - min(x)\nmax_minus_min <- function (x) {\n  dif <- max(x) - min(x)\n  return(dif)\n}\nmax_minus_min(x)\n\nmax_minus_min(gapminder$lifeExp)\nmax_minus_min(gapminder$gdpPercap)\nmax_minus_min(gapminder$country)\nmax_minus_min(gapminder$lifeExp)\nmax_minus_min(gapminder[c('lifeExp', 'gdpPercap', 'pop')])\n\n# write function that squares a value\nsqnum <- function(x){\n  x^2\n}\nsqnum(3)\n\n# write function that raises a value to any power\npowernum <- function(x, y){\n pow <- x^y\n return(pow)\n}\n# 2^3\npowernum(2,3)\n\n#\n## Tues 10/27/15\n#\n\nNt=Nt−1+r∗Nt−1∗(1−Nt−1/K)\n\npopgro <- function(pn, r, k){\n   n <- pn + r*pn * (1-pn/k)\n   return(n)\n}\n\npopgro(2, 1, 1000)\n\nfor ()\na) Given a starting population N1 of 2 individuals, a per capita growth rate of r=1, and carrying capacity of k=1000, how many individuals should there be in the next generation? I’ll give you a start for how I’d start to set myself up to calculate this in R.\n\ndgrowth <- function(ninit, r, k, ngen) {\n  graphics.off()\n  n <- rep(NA, ngen)\n  n[1] <- ninit\n  for (i in ninit:ngen) {\n    n[i] <- n[i-1] + r*n[i-1] * (1-(n[i-1]/k))\n  }\n  return(n)\n}\n\npop_100 <- dgrowth(2, 1, 1000, 100)\ntime_100 <- 1:100\npop_df <- data.frame(pop_100, time_100)\npop_df\nggplot(data = pop_df, aes(x = time_100, y = pop_100)) + \n  geom_line()\n\n\n\ndgrowth <- function(ninit, r, k, ngen) {\n n <- rep(NA, ngen)\n n[1] <- ninit\n  for (i in ninit:ngen) {\n    n[i] <- n[i-1] + r*n[i-1] * (1-(n[i-1]/k))\n  }\n t <- 1:ngen\n pop_df <- data.frame(n, t)\n colnames(pop_df) <- c('N', 'time')\n p1 <- ggplot(data = pop_df, aes(x = t, y = n)) + \n   geom_line()\nplot_list <- list(plot = p1, pop_df = pop_df)\nreturn(plot_list)\n}\n\npop_growth <-  dgrowth(2, 1, 1000, 100)\npop_growth[[1]]\npop_growth[[2]]\n  \nlibrary(ggplot2)\n\n\nclass(i)\n3) Cool! This function should return the population values for each generation. Let’s make a quick plot of how population increases with time.\n\na) First, let’s make a data frame where we bind one column of time values with our vector/column of population size at time step t (calcuated using our handy function). This time let’s look at 100 time steps.\n\nngen = 100\npop_100 <- \ntime_100 <- \npop_df <- data.frame(_________, _________)\n\nn[i] <- n[i-1] + r*n[i-1] * (1-(n[i-1]/k))\n\n# print(data_n)\n\nggplot(data = pop_df, aes(x = time_100, y = pop_100)) + \n  geom_line()\n\nngen <- 100\npopgro <- function(pn, r, k){\n  n <- pn + r*pn * (1-pn/k)\n  return(n)\n}\n\n\n# 4 Awesome! Ok. Now let’s do some exploring. Let’s take advantage of our newly minted function and our recent knowledge of for loops! I mentioned at the beginning of this exercise that changing the value of r changes the rate of population growth\n\n# Let’s calculate the population growth for 100 generations, starting at a population size of 1, and carrying capacity k of 1000. But, let’s play with values of r.\n\n# a) Set your input values in preparation for an upcoming for loop! We will be calculating a set of predicted populations based on values of r from 0.7 to 3 by an increment of 0.1. (remember to look up functions you haven’t seen before!)\n\n# Setup your data!\nninit = 1\nngen  = 100\nk = 1000\nr_vals = seq(0.7, 3, 0.1)\n\n# b) Before we begin, let’s take a detour to learn a new function that can be super handy. Sometimes you create one vector or dataframe and then want to add rows to it. Describe what is happening in the code below (add comments as notes for future you!)\n\ndgrowth <- function(ninit, r, k, ngen) {\n  graphics.off()\n   n <- rep(NA, ngen)\n   n[1] <- ninit\n  for (i in 2:ngen) {\n    n[i] <- n[i-1] + r*n[i-1] * (1-(n[i-1]/k))\n  }\n  return(n)\n}\n\npop1 <- dgrowth(r = 1, ninit = 1, k = 1000, ngen = 4)\npop_df1 <- data.frame(N = pop1, time = 1:4)\n\npop2 <- dgrowth(r = 2, ninit = 1, k = 1000, ngen = 4)\npop_df2 <- data.frame(N = pop2, time = 1:4)\n\npops_df <- rbind(pop_df1, pop_df2)\npops_df\n\n# c) Ok, back to looping. Let’s start by just making a loop that calculates the populations for 100 generations using our different values of r. You can look at the example for loops\n\ndgrowth <- function(ninit, r, k, ngen) {\n  n <- rep(NA, ngen)\n  n[1] <- ninit\n  for (i in 2:ngen) {\n    n[i] <- n[i-1] + r*n[i-1] * (1-(n[i-1]/k))\n  }\n  return(n)\n}\n\nlength(r_vals)\npops <- data.frame()\nclass(pops)\nfor (j in 1:length(r_vals)) {\n  pops <- dgrowth(r=r_vals[j], ninit = 2, k = 1000, ngen = 4)\n}\n\nr_vals = seq(0.7, 3, 0.1)\nninit <- 2\nk <- 1000\nngen <- 4\nr_vals[1]\npops <- data.frame(r = 0.6, t = 1:ngen, N = dgrowth(r = 1, ninit = ninit, k = k, ngen = ngen))\n\npops <- data.frame(r = 0.6, t = 1:ngen, N = dgrowth)\n\nfor (j in 1:length(r_vals)) {\n    pops[j] <- dgrowth(r=r_vals[j], ninit = 2, k = 1000, ngen = 4)\n    }\n\npops\nfor\nlength(r_vals)\nclass(r_vals)\nr_vals[2]\nclass(newgrowth)\nnewgrowth[2]\n\n# d) Now let’s store each new set of values in a data.frame called pops.\n\n# Create a dataframe with an initial population using r = 1. This is the \n# data.frame that we will add rows to.\n\npops <- data.frame(r = 0.6, t = 1:ngen, N = dgrowth(r = 1, ninit = ninit, k = k, ngen = ngen))\n\n\nfor(________){\n  N    <- ________\n  popr <- data.frame(________)\n  pops <- ________\n}\n\n# e) Yay! Time for more plots! See if you can make this one!\n  \n#  f) One last bit of fun. Let’s use some dplyr to grab the last 10 rows for each group of r values.\n\n# Now let’s plot those values and see what we get!\n\n###\n# Thurs. 10/29\n#\n\n  ",
    "created" : 1445950661791.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2496174922",
    "id" : "269DFBEF",
    "lastKnownWriteTime" : 1446132000,
    "path" : "~/R_projects copy/Intro-to-R/intro to r.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}